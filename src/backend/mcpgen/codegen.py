from __future__ import annotations
from pathlib import Path
import textwrap
from typing import Any
from jinja2 import Environment as JinjaEnv, BaseLoader
from .ir import IR, RuntimeEnv
from .util import write_text

# ---------------------------------------------------------------------------
# Templates
# ---------------------------------------------------------------------------

SERVER_TEMPLATE = r'''"""{{ description }}
Generated by mcpgen. Server: {{ server_name }}
"""
from __future__ import annotations
from typing import Any, List, Dict, Optional
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("{{ server_name }}", log_level="ERROR")

{% if environment.workdir_required %}
# FS sandbox
from pathlib import Path
import os
WORKDIR = Path(os.environ.get("WORKDIR", "/tmp")).resolve()
WORKDIR.mkdir(parents=True, exist_ok=True)

def _safe_path(rel: str) -> Path:
    p = (WORKDIR / rel).resolve()
    if not str(p).startswith(str(WORKDIR)):
        raise ValueError("path escapes WORKDIR")
    return p
{% endif %}

{% for imp in imports %}{{ imp }}
{% endfor %}

class GeneratedToolset:
    {% if tool_names %}
    _tool_names: tuple[str, ...] = ({% for name in tool_names %}"{{ name }}"{% if not loop.last %}, {% endif %}{% endfor %},)
    {% else %}
    _tool_names: tuple[str, ...] = ()
    {% endif %}

    def __iter__(self):
        for name in self._tool_names:
            yield getattr(self, name)

{% for t in tools %}
{% set method_block -%}
{% if t.is_async %}async {% endif %}def {{ t.name }}({{ t.method_params_str }}) -> {{ t.return_type }}:
{{ t.body_indented_method }}
{%- endset %}
{{ method_block | indent(4, True) }}

{% endfor %}

_toolset = GeneratedToolset()

{% for t in tools %}
@mcp.tool()
{% if t.is_async %}async {% endif %}def {{ t.name }}({{ t.params_str }}) -> {{ t.return_type }}:
    """{{ t.description }}"""
    {{ "return await " if t.is_async else "return " }}{{ t.call_expr }}

{% endfor %}

class GeneratedToolset:
    """Expose generated MCP tools as bound methods that can be iterated over."""
    _tool_names = {{ tool_names }}

    def __iter__(self):
        for tool_name in self._tool_names:
            yield getattr(self, tool_name)

{% for t in tools %}
{% if t.is_async %}    async def {{ t.name }}({{ t.method_params_str }}) -> {{ t.return_type }}:
        return await {{ t.name }}({{ t.call_args_str }})
{% else %}    def {{ t.name }}({{ t.method_params_str }}) -> {{ t.return_type }}:
        return {{ t.name }}({{ t.call_args_str }})
{% endif %}

{% endfor %}

if __name__ == "__main__":
    # stdio transport for agent runtimes
    mcp.run()
'''

REQUIREMENTS_TEMPLATE = r'''# Generated runtime requirements for the server
mcp>=1.6
{% for dep in dependencies %}{{ dep.name }}{{ dep.version }}
{% endfor %}
'''

# ---------------------------------------------------------------------------
# Policy
# ---------------------------------------------------------------------------

FORBIDDEN_FRAGMENTS = (
    "eval(", "exec(", "__import__", "compile(", "globals(", "locals(", "os.system(",
)

# allow-list for imports created from dependencies
ALLOWED_IMPORTS = {
    "openpyxl": "import openpyxl",
    "httpx": "import httpx",
    "pandas": "import pandas as pd",
    # "requests" intentionally blocked unless you change policy
}

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _indent(code: str, n: int = 4) -> str:
    pad = " " * n
    lines = code.rstrip("\n").splitlines() if code else []
    if not lines:
        return pad + "pass"
    return "\n".join(pad + ln for ln in lines)

def _scan_security(code: str, env: RuntimeEnv) -> None:
    for bad in FORBIDDEN_FRAGMENTS:
        if bad in code:
            raise ValueError(f"Forbidden fragment in implementation: {bad}")
    if not env.network_access and ("httpx" in code or "requests" in code):
        raise ValueError("Network access disabled but HTTP client found in implementation")

# ---------------------------------------------------------------------------
# Codegen
# ---------------------------------------------------------------------------

def generate(ir: IR, out_dir: Path) -> None:
    out_dir.mkdir(parents=True, exist_ok=True)

    # Build imports from deps using allow-list only
    imports: list[str] = []
    for dep in ir.dependencies:
        if dep.name == "requests":
            raise ValueError("Dependency 'requests' is blocked; use 'httpx' or enable network access.")
        stmt = ALLOWED_IMPORTS.get(dep.name)
        if stmt:
            imports.append(stmt)
        elif dep.name not in ALLOWED_IMPORTS:
            # Unknown runtime import; safer to fail than to inject arbitrary code
            raise ValueError(f"Dependency '{dep.name}' is not allow-listed for import.")

    tool_names = tuple(tool.name for tool in ir.tools)

    # Tools context
    tools_ctx = []
    for tool in ir.tools:
        _scan_security(tool.implementation, ir.environment)

        # parameters
        params_parts: list[str] = []
        annotated_params = [
            (p, "default" in getattr(p, "model_fields_set", set()))
            for p in tool.parameters
        ]
        # Python requires positional parameters without defaults before those with defaults.
        ordered_params = [item for item in annotated_params if not item[1]] + [
            item for item in annotated_params if item[1]
        ]
        call_args_parts: list[str] = []
        for p, has_default in ordered_params:
            if has_default:
                params_parts.append(f"{p.name}: {p.type} = {repr(p.default)}")
            else:
                params_parts.append(f"{p.name}: {p.type}")
            call_args_parts.append(p.name)

        # body
        body_src = textwrap.dedent(tool.implementation).strip()
        body_indented_method = _indent(body_src, 4)
        params_str = ", ".join(params_parts)
        method_params_str = "self"
        if params_str:
            method_params_str = f"self, {params_str}"
        call_args = ", ".join(call_args_parts)
        call_expr = f"_toolset.{tool.name}({call_args})" if call_args else f"_toolset.{tool.name}()"

        call_args_str = ", ".join(p.name for p, _ in ordered_params)
        method_params_parts = ["self"]
        method_params_parts.extend(params_parts)

        tools_ctx.append({
            "name": tool.name,
            "description": tool.description,
            "params_str": params_str,
            "method_params_str": method_params_str,
            "return_type": tool.return_type,
            "body_indented_method": body_indented_method,
            "call_expr": call_expr,
            "is_async": getattr(tool, "is_async", False),
            "method_params_str": ", ".join(method_params_parts),
            "call_args_str": call_args_str,
        })

    env = JinjaEnv(loader=BaseLoader(), autoescape=False, trim_blocks=True, lstrip_blocks=True)

    server_py = env.from_string(SERVER_TEMPLATE).render(
        server_name=ir.server_name,
        description=ir.description,
        tools=tools_ctx,
        imports=imports,
        environment=ir.environment,
        tool_names=tuple(tool.name for tool in ir.tools),
    )
    reqs_txt = env.from_string(REQUIREMENTS_TEMPLATE).render(dependencies=ir.dependencies)

    write_text(out_dir / "server.py", server_py)
    write_text(out_dir / "requirements.txt", reqs_txt)
    write_text(out_dir / "ir.json", ir.model_dump_json(indent=2))
